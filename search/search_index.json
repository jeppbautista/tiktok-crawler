{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tiktok Crawler A custom Python crawler written in Selenium for downloading Tiktok videos as mp4 files along with their metadata in a json file (author, tags, captions, etc.). Some key features of this project are: 1. Download videos from the for you page 2. Download videos based on search parameters NOTE \ud83d\udcdd This does not implement VPN or proxies for geolocation changes, meaning the Tiktok videos in the for you page will depend on the location of the machine where this library is run. If you are in the Philippines then the videos will be based on the for you page in the Philippines. How To Use: View the following files to see how to use the crawlers: 1. run_search_tiktok_videos.py Uses the class crawler.search.SearchCrawler to crawl the results of the search page from the given search parameter. IMPORTANT \u2757 As of writing, the class is unable to bypass Tiktok's captcha for the search results page. As a work around, the user needs to solve the captcha manually for the crawling to proceed. The program will timeout if the captcha is not solved after 60 seconds. 2. run_get_foryou_videos.py Uses the class crawler.foryoupage.CrawlerForYouPage to crawl Tiktok videos in the for you page. Output The output after running the functions above are json files containing the metadata and mp4 files of the tiktok videos. Each json file and mp4 file is a single tiktok video. They are identified by an internal id, meaning one tiktok video may have an id like f019457f-e39a-4601-9247-95e067864425 . The crawler functions will generate a f019457f-e39a-4601-9247-95e067864425.json and f019457f-e39a-4601-9247-95e067864425.mp4 file. f019457f-e39a-4601-9247-95e067864425.json: { \"id\": \"f019457f-e39a-4601-9247-95e067864425\", \"Author\": { \"uniqueid\": \"thecongtv\", \"nickname\": \"Cong Clothing\", \"link\": \"https://www.tiktok.com/@thecongtv\", \"avatar\": \"https://p16-sign-sg.tiktokcdn.com/aweme/100x100/tos-alisg-avt-0068/0292a1222969f10c614b327d93596135.jpeg?x-expires=1672488000&x-signature=rj5wD2aivUEyqkBkYFldu1i6lIY%3D\", \"element\": \"...\", \"Status\": null }, \"Caption\": { \"tags\": [], \"text\": \"mali ng naabutan si kuya..\", \"element\": \"<span class=\\\"tiktok-j2a19r-SpanText efbd9f0\\\">mali ng naabutan si kuya..</span>\" }, \"Music\": { \"title\": \"original sound - Cong Clothing\", \"link\": \"https://www.tiktok.com/music/original-sound-Cong-Clothing-7182437371232209690\", \"element\": \"...\" }, \"Media\": { \"link\": \"https://v16-webapp.tiktok.com/ea97a18c29595d41864754122d9dd471/63adda6c/video/tos/useast2a/tos-useast2a-pve-0037-aiso/owWzfA0MpBDhwWItIQLOhNp9nJ1hxUAaGhuKo0/?a=1988&ch=0&cr=0&dr=0&lr=tiktok&cd=0%7C0%7C1%7C0&cv=1&br=3584&bt=1792&cs=0&ds=3&ft=H3bLjvT4Q9wUxdYCt2HC~MiygGa-W.RUX17S2a6a-x4kS&mime_type=video_mp4&qs=0&rc=OTw7ZjZmaDtlZDM7OzszPEBpampsOTY6ZnhsaDMzZjgzM0AtM2M0NC0zNS0xMjAvLTA2YSNocWozcjRnNWpgLS1kL2Nzcw%3D%3D&l=20221229121934E761197971B88621B22F&btag=80000\", \"element\": \"...\" }, \"Metrics\": { \"likes\": \"76.2K\", \"comments\": \"246\", \"shares\": \"212\", \"as_of\": \"2022-12-29T20:19:30.194738\", \"element\": \"...\" } }","title":"Tiktok Crawler"},{"location":"#tiktok-crawler","text":"A custom Python crawler written in Selenium for downloading Tiktok videos as mp4 files along with their metadata in a json file (author, tags, captions, etc.). Some key features of this project are: 1. Download videos from the for you page 2. Download videos based on search parameters NOTE \ud83d\udcdd This does not implement VPN or proxies for geolocation changes, meaning the Tiktok videos in the for you page will depend on the location of the machine where this library is run. If you are in the Philippines then the videos will be based on the for you page in the Philippines.","title":"Tiktok Crawler"},{"location":"#how-to-use","text":"View the following files to see how to use the crawlers:","title":"How To Use:"},{"location":"#1-run_search_tiktok_videospy","text":"Uses the class crawler.search.SearchCrawler to crawl the results of the search page from the given search parameter. IMPORTANT \u2757 As of writing, the class is unable to bypass Tiktok's captcha for the search results page. As a work around, the user needs to solve the captcha manually for the crawling to proceed. The program will timeout if the captcha is not solved after 60 seconds.","title":"1. run_search_tiktok_videos.py"},{"location":"#2-run_get_foryou_videospy","text":"Uses the class crawler.foryoupage.CrawlerForYouPage to crawl Tiktok videos in the for you page.","title":"2. run_get_foryou_videos.py"},{"location":"#output","text":"The output after running the functions above are json files containing the metadata and mp4 files of the tiktok videos. Each json file and mp4 file is a single tiktok video. They are identified by an internal id, meaning one tiktok video may have an id like f019457f-e39a-4601-9247-95e067864425 . The crawler functions will generate a f019457f-e39a-4601-9247-95e067864425.json and f019457f-e39a-4601-9247-95e067864425.mp4 file. f019457f-e39a-4601-9247-95e067864425.json: { \"id\": \"f019457f-e39a-4601-9247-95e067864425\", \"Author\": { \"uniqueid\": \"thecongtv\", \"nickname\": \"Cong Clothing\", \"link\": \"https://www.tiktok.com/@thecongtv\", \"avatar\": \"https://p16-sign-sg.tiktokcdn.com/aweme/100x100/tos-alisg-avt-0068/0292a1222969f10c614b327d93596135.jpeg?x-expires=1672488000&x-signature=rj5wD2aivUEyqkBkYFldu1i6lIY%3D\", \"element\": \"...\", \"Status\": null }, \"Caption\": { \"tags\": [], \"text\": \"mali ng naabutan si kuya..\", \"element\": \"<span class=\\\"tiktok-j2a19r-SpanText efbd9f0\\\">mali ng naabutan si kuya..</span>\" }, \"Music\": { \"title\": \"original sound - Cong Clothing\", \"link\": \"https://www.tiktok.com/music/original-sound-Cong-Clothing-7182437371232209690\", \"element\": \"...\" }, \"Media\": { \"link\": \"https://v16-webapp.tiktok.com/ea97a18c29595d41864754122d9dd471/63adda6c/video/tos/useast2a/tos-useast2a-pve-0037-aiso/owWzfA0MpBDhwWItIQLOhNp9nJ1hxUAaGhuKo0/?a=1988&ch=0&cr=0&dr=0&lr=tiktok&cd=0%7C0%7C1%7C0&cv=1&br=3584&bt=1792&cs=0&ds=3&ft=H3bLjvT4Q9wUxdYCt2HC~MiygGa-W.RUX17S2a6a-x4kS&mime_type=video_mp4&qs=0&rc=OTw7ZjZmaDtlZDM7OzszPEBpampsOTY6ZnhsaDMzZjgzM0AtM2M0NC0zNS0xMjAvLTA2YSNocWozcjRnNWpgLS1kL2Nzcw%3D%3D&l=20221229121934E761197971B88621B22F&btag=80000\", \"element\": \"...\" }, \"Metrics\": { \"likes\": \"76.2K\", \"comments\": \"246\", \"shares\": \"212\", \"as_of\": \"2022-12-29T20:19:30.194738\", \"element\": \"...\" } }","title":"Output"},{"location":"crawler/","text":"Crawler SearchCrawler Bases: Crawler Handles the web crawling of videos from the Search results page. Parameters: Name Type Description Default search str The raw search term. required limit int Defines how many videos to download. 15 driver_options list Implements the chromium command line switches. See here: https://peter.sh/experiments/chromium-command-line-switches/ None Source code in tiktok_crawler\\crawler\\search.py class SearchCrawler(Crawler): \"\"\"Handles the web crawling of videos from the **Search results** page. Args: search (str): The raw search term. limit (int): Defines how many videos to download. driver_options (list): Implements the chromium command line switches. See here: https://peter.sh/experiments/chromium-command-line-switches/ \"\"\" def __init__( self, search, limit:int = 15, driver_options:list = None ) -> None: options = driver_options if isinstance(driver_options, list) else [] self.driver = Driver(*options).get_driver() self.limit = limit self.search = quote_plus(search) search_url = f\"{Config.CRAWL_SEARCH_URL}q={self.search}\" self.root = self._get_root(search_url) def get_tiktok_videos(self) -> list[Tiktok]: \"\"\"Downloads videos and metadata from the **search results** page of Tiktok. Returns: list[Tiktok]: list of `tiktok_crawler.entities.Tiktok` \"\"\" self._wait_for_captcha() self._load_tiktok_videos() tiktok_links = self._get_tiktok_links() tiktoks = [] for tiktok_link in tiktok_links: try: self.driver.get(tiktok_link) tiktok_container = self.driver.find_element(By.XPATH, search.TiktokVideo.CONTAINER) tiktoks.append(self._get_tiktok(tiktok_container)) except StaleElementReferenceException: logging.error(\"Stale Element\") return tiktoks def _get_tiktok_links(self) -> list[WebElement]: return [element.get_attribute(\"href\") for element in self.root.find_elements(By.XPATH, search.ContainerItem.TIKTOK_VIDEOS)][:self.limit] def _get_root(self, url: str) -> WebElement: logging.info(f\"Loading: {url}\") self.driver.get(url) root = self.driver.find_element(By.XPATH, search.Root.ROOT) return root def _load_tiktok_videos(self) -> None: \"\"\"Loads TikTok videos by scrolling and clicking the 'Load More' button. The function will keep scrolling and loading more TikTok videos until it has reached the limit specified in the `self.limit` attribute. If no elements are found using the XPATH specified in `search.ContainerItem.TIKTOK_VIDEOS`, a `NoElementsFound` exception is raised. \"\"\" tiktok_links = [] while len(tiktok_links) < self.limit: logging.info(\"Scrolling...\") self.driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") tiktok_links = tiktok_links + self.root.find_elements(By.XPATH, search.ContainerItem.TIKTOK_VIDEOS) if len(tiktok_links) == 0: raise NoElementsFound(f\"No elements found from given XPATH: {search.ContainerItem.TIKTOK_VIDEOS}\") logging.info(f\"Element count: {len(tiktok_links)}\") load_more_button = WebDriverWait(self.driver, 10).until( EC.presence_of_element_located((By.XPATH, search.ContainerItem.LOAD_MORE_BUTTON)) ) load_more_button.click() time.sleep(Config.CRAWL_SCROLL_PAUSE_TIME) def _wait_for_captcha(self): \"\"\"Waits for the user to solve a captcha, if present. \"\"\" try: WebDriverWait(self.driver, 10).until( EC.presence_of_element_located((By.XPATH, search.ContainerItem.CAPTCHA)) ) logging.warning(\"Process will timeout in 60 seconds if captcha is not solved.\") logging.warning(\"Waiting for user to solve captcha...\") WebDriverWait(self.driver, 60).until_not( EC.presence_of_element_located((By.XPATH, search.ContainerItem.CAPTCHA)) ) logging.info(\"Captcha Solved. Proceeding to crawl...\") time.sleep(5) except TimeoutException: raise CaptchaTimeoutException(\"Captcha needs to be solved within 60 seconds\") ### Get entities def _get_author(self, item_container: WebElement) -> Author: \"\"\"Extracts the information about the account who posted the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Author: Returns a `tiktok_crawler.entities.Author` instance. \"\"\" uniqueid = item_container.find_element(By.XPATH, search.Author.UNIQUEID).text avatar = \"\" link = item_container.find_element(By.XPATH, search.Author.LINK).get_attribute(\"href\") nickname = item_container.find_element(By.XPATH, search.Author.NICKNAME).text author = Author( uniqueid=uniqueid, avatar=avatar, link=link, nickname=nickname, element=item_container ) return author def _get_caption(self, item_container: WebElement) -> Caption: \"\"\"Extracts the caption attached with the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Caption: Returns a `tiktok_crawler.entities.Caption` instance. \"\"\" video_description = item_container.find_element(By.XPATH, search.Caption.CONTAINER) video_text = video_description.find_element(By.XPATH, search.Caption.TEXT).text tags = self._get_tags(video_description) caption = Caption( text=video_text, tags=tags, element=video_description ) return caption def _get_media(self, item_container: WebElement) -> Media: \"\"\"Extracts the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Media: Returns a `tiktok_crawler.entities.Media` instance. Raises: MediaNotFoundException: if the crawler was unable to download the Tiktok video. \"\"\" media_container = item_container.find_element(By.XPATH, search.Media.CONTAINER) try: link = WebDriverWait(media_container, 10).until( EC.presence_of_element_located((By.XPATH, f\"{search.Media.LINK}|{search.Media.LINK_ALT}\")) ).get_attribute(\"src\") except TimeoutException: try: link = WebDriverWait(media_container, 10).until( EC.presence_of_element_located((By.XPATH, f\"{search.Media.LINK}|{search.Media.LINK_ALT}\")) ).get_attribute(\"src\") except TimeoutException: raise MediaNotFoundException(\"Unable to find Media\") media = Media( link=link, element=media_container ) return media def _get_metrics(self, item_container: WebElement) -> Metrics: \"\"\"Extracts the metrics of the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Metrics: Returns a `tiktok_crawler.entities.Metrics` instance. \"\"\" metrics_container = item_container.find_element(By.XPATH, search.Metrics.CONTAINER) likes = metrics_container.find_element(By.XPATH, search.Metrics.LIKES).text comments = metrics_container.find_element(By.XPATH, search.Metrics.COMMENTS).text shares = metrics_container.find_element(By.XPATH, search.Metrics.SHARES).text metrics = Metrics( likes=likes, comments=comments, shares=shares, element=metrics_container ) return metrics def _get_music(self, item_container: WebElement) -> Music: \"\"\"Extracts the music of the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Music: Returns a `tiktok_crawler.entities.Music` instance. \"\"\" music_container = item_container.find_element(By.XPATH, search.Music.CONTAINER) title = music_container.find_element(By.XPATH, search.Music.TITLE).text link = music_container.find_element(By.XPATH, search.Music.LINK).get_attribute(\"href\") music = Music( title=title, link=link, element=music_container ) return music def _get_tags(self, video_description: WebElement) -> list[Tag]: \"\"\"Extracts the tags in the caption of the Tiktok video. Args: video_description (WebElement): Accepts a Selenium web element which is the extracted video container (see `_get_caption()`) of a Tiktok video. Returns: list[Tag]: List of `tiktok_crawler.entities.Tag` \"\"\" _tags = [] for tag in video_description.find_elements(By.XPATH, search.Caption.TAGS): link = tag.get_attribute(\"href\") text = tag.find_element(By.XPATH, search.Tag.TEXT).text _tags.append( Tag( link=link, text=text, element=tag ) ) return _tags get_tiktok_videos() Downloads videos and metadata from the search results page of Tiktok. Returns: Type Description list [ Tiktok ] list[Tiktok]: list of tiktok_crawler.entities.Tiktok Source code in tiktok_crawler\\crawler\\search.py def get_tiktok_videos(self) -> list[Tiktok]: \"\"\"Downloads videos and metadata from the **search results** page of Tiktok. Returns: list[Tiktok]: list of `tiktok_crawler.entities.Tiktok` \"\"\" self._wait_for_captcha() self._load_tiktok_videos() tiktok_links = self._get_tiktok_links() tiktoks = [] for tiktok_link in tiktok_links: try: self.driver.get(tiktok_link) tiktok_container = self.driver.find_element(By.XPATH, search.TiktokVideo.CONTAINER) tiktoks.append(self._get_tiktok(tiktok_container)) except StaleElementReferenceException: logging.error(\"Stale Element\") return tiktoks CrawlerForYouPage Bases: Crawler Handles the web crawling of videos from the For You page. Parameters: Name Type Description Default limit int Defines how many videos to download. 15 driver_options list Implements the chromium command line switches. See here: https://peter.sh/experiments/chromium-command-line-switches/ None Source code in tiktok_crawler\\crawler\\foryoupage.py class CrawlerForYouPage(Crawler): \"\"\"Handles the web crawling of videos from the **For You** page. Args: limit (int): Defines how many videos to download. driver_options (list): Implements the chromium command line switches. See here: https://peter.sh/experiments/chromium-command-line-switches/ \"\"\" def __init__( self, limit:int = 15, driver_options:list = None ) -> None: options = driver_options if isinstance(driver_options, list) else [] self.driver = Driver(*options).get_driver() self.limit = limit self.root = self._get_root(Config.CRAWL_ROOT_URL) def get_tiktok_videos(self) -> list[Tiktok]: \"\"\"Downloads videos and metadata from the **for you** page of Tiktok. Returns: list[Tiktok]: list of `tiktok_crawler.entities.Tiktok` \"\"\" self._load_tiktok_videos() tiktoks = [] for element in self.root.find_elements(By.XPATH, foryoupage.ContainerItem.CONTAINERS)[:self.limit]: logging.info(\"Scrolling to Element...\") self.driver.execute_script(\"arguments[0].scrollIntoView()\", element) time.sleep(Config.CRAWL_SCROLL_PAUSE_TIME) tiktok = self._get_tiktok(element) tiktoks.append(tiktok) return tiktoks def _get_root(self, url:str) -> WebElement: \"\"\"Extracts the root element of the page. This is done to remove unnecessary HTML elements such as the *head*, *script* and *style*. Args: url (str): The url of the page to be extracted. Returns: WebElement: Returns a Selenium web element which is the extracted root element of the page. \"\"\" self.driver.get(url) root = self.driver.find_element(By.XPATH, foryoupage.Root.ROOT) return root def _load_tiktok_videos(self) -> None: \"\"\"Pre-loads tiktok videos by scrolling down until `self.limit` is exceeded or reached. \"\"\" def _is_limit_reached() -> bool: \"\"\"Checks if the number of elements in `xpath.ContainerItem.CONTAINERS` has reached or exceeded `self.limit` Returns: bool: `self.limit` <= the number of elements in `xpath.ContainerItem.CONTAINERS` \"\"\" element_count = len([element for element in self.root.find_elements(By.XPATH, foryoupage.ContainerItem.CONTAINERS)]) logging.info(f\"Element count: {element_count}\") return self.limit <= element_count while not _is_limit_reached(): logging.info(\"Scrolling...\") self.driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") time.sleep(Config.CRAWL_SCROLL_PAUSE_TIME) ### Get entities def _get_author(self, item_container: WebElement) -> Author: \"\"\"Extracts the information about the account who posted the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Author: Returns a `tiktok_crawler.entities.Author` instance. \"\"\" uniqueid = item_container.find_element(By.XPATH, foryoupage.Author.UNIQUEID).text avatar = item_container.find_element(By.XPATH, foryoupage.Author.AVATAR).get_attribute(\"src\") link = item_container.find_element(By.XPATH, foryoupage.Author.LINK).get_attribute(\"href\") nickname = item_container.find_element(By.XPATH, foryoupage.Author.NICKNAME).text author = Author( uniqueid=uniqueid, avatar=avatar, link=link, nickname=nickname, element=item_container ) return author def _get_caption(self, item_container: WebElement) -> Caption: \"\"\"Extracts the caption attached with the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Caption: Returns a `tiktok_crawler.entities.Caption` instance. \"\"\" video_description = item_container.find_element(By.XPATH, foryoupage.Caption.CONTAINER) video_text = video_description.find_element(By.XPATH, foryoupage.Caption.TEXT).text tags = self._get_tags(video_description) caption = Caption( text=video_text, tags=tags, element=video_description ) return caption def _get_media(self, item_container: WebElement) -> Media: \"\"\"Extracts the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Media: Returns a `tiktok_crawler.entities.Media` instance. Raises: MediaNotFoundException: if the crawler was unable to download the Tiktok video. \"\"\" media_container = item_container.find_element(By.XPATH, foryoupage.Media.CONTAINER) try: link = WebDriverWait(media_container, 10).until( EC.presence_of_element_located((By.XPATH, f\"{foryoupage.Media.LINK}|{foryoupage.Media.LINK_ALT}\")) ).get_attribute(\"src\") except TimeoutException: try: link = WebDriverWait(media_container, 10).until( EC.presence_of_element_located((By.XPATH, f\"{foryoupage.Media.LINK}|{foryoupage.Media.LINK_ALT}\")) ).get_attribute(\"src\") except TimeoutException: raise exception.MediaNotFoundException(\"Unable to find Media\") media = Media( link=link, element=media_container ) return media def _get_metrics(self, item_container: WebElement) -> Metrics: \"\"\"Extracts the metrics of the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Metrics: Returns a `tiktok_crawler.entities.Metrics` instance. \"\"\" metrics_container = item_container.find_element(By.XPATH, foryoupage.Metrics.CONTAINER) likes = metrics_container.find_element(By.XPATH, foryoupage.Metrics.LIKES).text comments = metrics_container.find_element(By.XPATH, foryoupage.Metrics.COMMENTS).text shares = metrics_container.find_element(By.XPATH, foryoupage.Metrics.SHARES).text metrics = Metrics( likes=likes, comments=comments, shares=shares, element=metrics_container ) return metrics def _get_music(self, item_container: WebElement) -> Music: \"\"\"Extracts the music of the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Music: Returns a `tiktok_crawler.entities.Music` instance. \"\"\" music_container = item_container.find_element(By.XPATH, foryoupage.Music.CONTAINER) title = music_container.find_element(By.XPATH, foryoupage.Music.TITLE).text link = music_container.find_element(By.XPATH, foryoupage.Music.LINK).get_attribute(\"href\") music = Music( title=title, link=link, element=music_container ) return music def _get_tags(self, video_description: WebElement) -> list[Tag]: \"\"\"Extracts the tags in the caption of the Tiktok video. Args: video_description (WebElement): Accepts a Selenium web element which is the extracted video container (see `_get_caption()`) of a Tiktok video. Returns: list[Tag]: List of `tiktok_crawler.entities.Tag` \"\"\" _tags = [] for tag in video_description.find_elements(By.XPATH, foryoupage.Caption.TAGS): link = tag.get_attribute(\"href\") text = tag.find_element(By.XPATH, foryoupage.Tag.TEXT).text _tags.append( Tag( link=link, text=text, element=tag ) ) return _tags get_tiktok_videos() Downloads videos and metadata from the for you page of Tiktok. Returns: Type Description list [ Tiktok ] list[Tiktok]: list of tiktok_crawler.entities.Tiktok Source code in tiktok_crawler\\crawler\\foryoupage.py def get_tiktok_videos(self) -> list[Tiktok]: \"\"\"Downloads videos and metadata from the **for you** page of Tiktok. Returns: list[Tiktok]: list of `tiktok_crawler.entities.Tiktok` \"\"\" self._load_tiktok_videos() tiktoks = [] for element in self.root.find_elements(By.XPATH, foryoupage.ContainerItem.CONTAINERS)[:self.limit]: logging.info(\"Scrolling to Element...\") self.driver.execute_script(\"arguments[0].scrollIntoView()\", element) time.sleep(Config.CRAWL_SCROLL_PAUSE_TIME) tiktok = self._get_tiktok(element) tiktoks.append(tiktok) return tiktoks","title":"Crawler"},{"location":"crawler/#crawler","text":"","title":"Crawler"},{"location":"crawler/#tiktok_crawler.crawler.search.SearchCrawler","text":"Bases: Crawler Handles the web crawling of videos from the Search results page. Parameters: Name Type Description Default search str The raw search term. required limit int Defines how many videos to download. 15 driver_options list Implements the chromium command line switches. See here: https://peter.sh/experiments/chromium-command-line-switches/ None Source code in tiktok_crawler\\crawler\\search.py class SearchCrawler(Crawler): \"\"\"Handles the web crawling of videos from the **Search results** page. Args: search (str): The raw search term. limit (int): Defines how many videos to download. driver_options (list): Implements the chromium command line switches. See here: https://peter.sh/experiments/chromium-command-line-switches/ \"\"\" def __init__( self, search, limit:int = 15, driver_options:list = None ) -> None: options = driver_options if isinstance(driver_options, list) else [] self.driver = Driver(*options).get_driver() self.limit = limit self.search = quote_plus(search) search_url = f\"{Config.CRAWL_SEARCH_URL}q={self.search}\" self.root = self._get_root(search_url) def get_tiktok_videos(self) -> list[Tiktok]: \"\"\"Downloads videos and metadata from the **search results** page of Tiktok. Returns: list[Tiktok]: list of `tiktok_crawler.entities.Tiktok` \"\"\" self._wait_for_captcha() self._load_tiktok_videos() tiktok_links = self._get_tiktok_links() tiktoks = [] for tiktok_link in tiktok_links: try: self.driver.get(tiktok_link) tiktok_container = self.driver.find_element(By.XPATH, search.TiktokVideo.CONTAINER) tiktoks.append(self._get_tiktok(tiktok_container)) except StaleElementReferenceException: logging.error(\"Stale Element\") return tiktoks def _get_tiktok_links(self) -> list[WebElement]: return [element.get_attribute(\"href\") for element in self.root.find_elements(By.XPATH, search.ContainerItem.TIKTOK_VIDEOS)][:self.limit] def _get_root(self, url: str) -> WebElement: logging.info(f\"Loading: {url}\") self.driver.get(url) root = self.driver.find_element(By.XPATH, search.Root.ROOT) return root def _load_tiktok_videos(self) -> None: \"\"\"Loads TikTok videos by scrolling and clicking the 'Load More' button. The function will keep scrolling and loading more TikTok videos until it has reached the limit specified in the `self.limit` attribute. If no elements are found using the XPATH specified in `search.ContainerItem.TIKTOK_VIDEOS`, a `NoElementsFound` exception is raised. \"\"\" tiktok_links = [] while len(tiktok_links) < self.limit: logging.info(\"Scrolling...\") self.driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") tiktok_links = tiktok_links + self.root.find_elements(By.XPATH, search.ContainerItem.TIKTOK_VIDEOS) if len(tiktok_links) == 0: raise NoElementsFound(f\"No elements found from given XPATH: {search.ContainerItem.TIKTOK_VIDEOS}\") logging.info(f\"Element count: {len(tiktok_links)}\") load_more_button = WebDriverWait(self.driver, 10).until( EC.presence_of_element_located((By.XPATH, search.ContainerItem.LOAD_MORE_BUTTON)) ) load_more_button.click() time.sleep(Config.CRAWL_SCROLL_PAUSE_TIME) def _wait_for_captcha(self): \"\"\"Waits for the user to solve a captcha, if present. \"\"\" try: WebDriverWait(self.driver, 10).until( EC.presence_of_element_located((By.XPATH, search.ContainerItem.CAPTCHA)) ) logging.warning(\"Process will timeout in 60 seconds if captcha is not solved.\") logging.warning(\"Waiting for user to solve captcha...\") WebDriverWait(self.driver, 60).until_not( EC.presence_of_element_located((By.XPATH, search.ContainerItem.CAPTCHA)) ) logging.info(\"Captcha Solved. Proceeding to crawl...\") time.sleep(5) except TimeoutException: raise CaptchaTimeoutException(\"Captcha needs to be solved within 60 seconds\") ### Get entities def _get_author(self, item_container: WebElement) -> Author: \"\"\"Extracts the information about the account who posted the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Author: Returns a `tiktok_crawler.entities.Author` instance. \"\"\" uniqueid = item_container.find_element(By.XPATH, search.Author.UNIQUEID).text avatar = \"\" link = item_container.find_element(By.XPATH, search.Author.LINK).get_attribute(\"href\") nickname = item_container.find_element(By.XPATH, search.Author.NICKNAME).text author = Author( uniqueid=uniqueid, avatar=avatar, link=link, nickname=nickname, element=item_container ) return author def _get_caption(self, item_container: WebElement) -> Caption: \"\"\"Extracts the caption attached with the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Caption: Returns a `tiktok_crawler.entities.Caption` instance. \"\"\" video_description = item_container.find_element(By.XPATH, search.Caption.CONTAINER) video_text = video_description.find_element(By.XPATH, search.Caption.TEXT).text tags = self._get_tags(video_description) caption = Caption( text=video_text, tags=tags, element=video_description ) return caption def _get_media(self, item_container: WebElement) -> Media: \"\"\"Extracts the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Media: Returns a `tiktok_crawler.entities.Media` instance. Raises: MediaNotFoundException: if the crawler was unable to download the Tiktok video. \"\"\" media_container = item_container.find_element(By.XPATH, search.Media.CONTAINER) try: link = WebDriverWait(media_container, 10).until( EC.presence_of_element_located((By.XPATH, f\"{search.Media.LINK}|{search.Media.LINK_ALT}\")) ).get_attribute(\"src\") except TimeoutException: try: link = WebDriverWait(media_container, 10).until( EC.presence_of_element_located((By.XPATH, f\"{search.Media.LINK}|{search.Media.LINK_ALT}\")) ).get_attribute(\"src\") except TimeoutException: raise MediaNotFoundException(\"Unable to find Media\") media = Media( link=link, element=media_container ) return media def _get_metrics(self, item_container: WebElement) -> Metrics: \"\"\"Extracts the metrics of the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Metrics: Returns a `tiktok_crawler.entities.Metrics` instance. \"\"\" metrics_container = item_container.find_element(By.XPATH, search.Metrics.CONTAINER) likes = metrics_container.find_element(By.XPATH, search.Metrics.LIKES).text comments = metrics_container.find_element(By.XPATH, search.Metrics.COMMENTS).text shares = metrics_container.find_element(By.XPATH, search.Metrics.SHARES).text metrics = Metrics( likes=likes, comments=comments, shares=shares, element=metrics_container ) return metrics def _get_music(self, item_container: WebElement) -> Music: \"\"\"Extracts the music of the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Music: Returns a `tiktok_crawler.entities.Music` instance. \"\"\" music_container = item_container.find_element(By.XPATH, search.Music.CONTAINER) title = music_container.find_element(By.XPATH, search.Music.TITLE).text link = music_container.find_element(By.XPATH, search.Music.LINK).get_attribute(\"href\") music = Music( title=title, link=link, element=music_container ) return music def _get_tags(self, video_description: WebElement) -> list[Tag]: \"\"\"Extracts the tags in the caption of the Tiktok video. Args: video_description (WebElement): Accepts a Selenium web element which is the extracted video container (see `_get_caption()`) of a Tiktok video. Returns: list[Tag]: List of `tiktok_crawler.entities.Tag` \"\"\" _tags = [] for tag in video_description.find_elements(By.XPATH, search.Caption.TAGS): link = tag.get_attribute(\"href\") text = tag.find_element(By.XPATH, search.Tag.TEXT).text _tags.append( Tag( link=link, text=text, element=tag ) ) return _tags","title":"SearchCrawler"},{"location":"crawler/#tiktok_crawler.crawler.search.SearchCrawler.get_tiktok_videos","text":"Downloads videos and metadata from the search results page of Tiktok. Returns: Type Description list [ Tiktok ] list[Tiktok]: list of tiktok_crawler.entities.Tiktok Source code in tiktok_crawler\\crawler\\search.py def get_tiktok_videos(self) -> list[Tiktok]: \"\"\"Downloads videos and metadata from the **search results** page of Tiktok. Returns: list[Tiktok]: list of `tiktok_crawler.entities.Tiktok` \"\"\" self._wait_for_captcha() self._load_tiktok_videos() tiktok_links = self._get_tiktok_links() tiktoks = [] for tiktok_link in tiktok_links: try: self.driver.get(tiktok_link) tiktok_container = self.driver.find_element(By.XPATH, search.TiktokVideo.CONTAINER) tiktoks.append(self._get_tiktok(tiktok_container)) except StaleElementReferenceException: logging.error(\"Stale Element\") return tiktoks","title":"get_tiktok_videos()"},{"location":"crawler/#tiktok_crawler.crawler.foryoupage.CrawlerForYouPage","text":"Bases: Crawler Handles the web crawling of videos from the For You page. Parameters: Name Type Description Default limit int Defines how many videos to download. 15 driver_options list Implements the chromium command line switches. See here: https://peter.sh/experiments/chromium-command-line-switches/ None Source code in tiktok_crawler\\crawler\\foryoupage.py class CrawlerForYouPage(Crawler): \"\"\"Handles the web crawling of videos from the **For You** page. Args: limit (int): Defines how many videos to download. driver_options (list): Implements the chromium command line switches. See here: https://peter.sh/experiments/chromium-command-line-switches/ \"\"\" def __init__( self, limit:int = 15, driver_options:list = None ) -> None: options = driver_options if isinstance(driver_options, list) else [] self.driver = Driver(*options).get_driver() self.limit = limit self.root = self._get_root(Config.CRAWL_ROOT_URL) def get_tiktok_videos(self) -> list[Tiktok]: \"\"\"Downloads videos and metadata from the **for you** page of Tiktok. Returns: list[Tiktok]: list of `tiktok_crawler.entities.Tiktok` \"\"\" self._load_tiktok_videos() tiktoks = [] for element in self.root.find_elements(By.XPATH, foryoupage.ContainerItem.CONTAINERS)[:self.limit]: logging.info(\"Scrolling to Element...\") self.driver.execute_script(\"arguments[0].scrollIntoView()\", element) time.sleep(Config.CRAWL_SCROLL_PAUSE_TIME) tiktok = self._get_tiktok(element) tiktoks.append(tiktok) return tiktoks def _get_root(self, url:str) -> WebElement: \"\"\"Extracts the root element of the page. This is done to remove unnecessary HTML elements such as the *head*, *script* and *style*. Args: url (str): The url of the page to be extracted. Returns: WebElement: Returns a Selenium web element which is the extracted root element of the page. \"\"\" self.driver.get(url) root = self.driver.find_element(By.XPATH, foryoupage.Root.ROOT) return root def _load_tiktok_videos(self) -> None: \"\"\"Pre-loads tiktok videos by scrolling down until `self.limit` is exceeded or reached. \"\"\" def _is_limit_reached() -> bool: \"\"\"Checks if the number of elements in `xpath.ContainerItem.CONTAINERS` has reached or exceeded `self.limit` Returns: bool: `self.limit` <= the number of elements in `xpath.ContainerItem.CONTAINERS` \"\"\" element_count = len([element for element in self.root.find_elements(By.XPATH, foryoupage.ContainerItem.CONTAINERS)]) logging.info(f\"Element count: {element_count}\") return self.limit <= element_count while not _is_limit_reached(): logging.info(\"Scrolling...\") self.driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") time.sleep(Config.CRAWL_SCROLL_PAUSE_TIME) ### Get entities def _get_author(self, item_container: WebElement) -> Author: \"\"\"Extracts the information about the account who posted the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Author: Returns a `tiktok_crawler.entities.Author` instance. \"\"\" uniqueid = item_container.find_element(By.XPATH, foryoupage.Author.UNIQUEID).text avatar = item_container.find_element(By.XPATH, foryoupage.Author.AVATAR).get_attribute(\"src\") link = item_container.find_element(By.XPATH, foryoupage.Author.LINK).get_attribute(\"href\") nickname = item_container.find_element(By.XPATH, foryoupage.Author.NICKNAME).text author = Author( uniqueid=uniqueid, avatar=avatar, link=link, nickname=nickname, element=item_container ) return author def _get_caption(self, item_container: WebElement) -> Caption: \"\"\"Extracts the caption attached with the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Caption: Returns a `tiktok_crawler.entities.Caption` instance. \"\"\" video_description = item_container.find_element(By.XPATH, foryoupage.Caption.CONTAINER) video_text = video_description.find_element(By.XPATH, foryoupage.Caption.TEXT).text tags = self._get_tags(video_description) caption = Caption( text=video_text, tags=tags, element=video_description ) return caption def _get_media(self, item_container: WebElement) -> Media: \"\"\"Extracts the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Media: Returns a `tiktok_crawler.entities.Media` instance. Raises: MediaNotFoundException: if the crawler was unable to download the Tiktok video. \"\"\" media_container = item_container.find_element(By.XPATH, foryoupage.Media.CONTAINER) try: link = WebDriverWait(media_container, 10).until( EC.presence_of_element_located((By.XPATH, f\"{foryoupage.Media.LINK}|{foryoupage.Media.LINK_ALT}\")) ).get_attribute(\"src\") except TimeoutException: try: link = WebDriverWait(media_container, 10).until( EC.presence_of_element_located((By.XPATH, f\"{foryoupage.Media.LINK}|{foryoupage.Media.LINK_ALT}\")) ).get_attribute(\"src\") except TimeoutException: raise exception.MediaNotFoundException(\"Unable to find Media\") media = Media( link=link, element=media_container ) return media def _get_metrics(self, item_container: WebElement) -> Metrics: \"\"\"Extracts the metrics of the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Metrics: Returns a `tiktok_crawler.entities.Metrics` instance. \"\"\" metrics_container = item_container.find_element(By.XPATH, foryoupage.Metrics.CONTAINER) likes = metrics_container.find_element(By.XPATH, foryoupage.Metrics.LIKES).text comments = metrics_container.find_element(By.XPATH, foryoupage.Metrics.COMMENTS).text shares = metrics_container.find_element(By.XPATH, foryoupage.Metrics.SHARES).text metrics = Metrics( likes=likes, comments=comments, shares=shares, element=metrics_container ) return metrics def _get_music(self, item_container: WebElement) -> Music: \"\"\"Extracts the music of the Tiktok video. Args: item_container (WebElement): Accepts a Selenium web element which is the extracted container of a Tiktok video. Returns: Music: Returns a `tiktok_crawler.entities.Music` instance. \"\"\" music_container = item_container.find_element(By.XPATH, foryoupage.Music.CONTAINER) title = music_container.find_element(By.XPATH, foryoupage.Music.TITLE).text link = music_container.find_element(By.XPATH, foryoupage.Music.LINK).get_attribute(\"href\") music = Music( title=title, link=link, element=music_container ) return music def _get_tags(self, video_description: WebElement) -> list[Tag]: \"\"\"Extracts the tags in the caption of the Tiktok video. Args: video_description (WebElement): Accepts a Selenium web element which is the extracted video container (see `_get_caption()`) of a Tiktok video. Returns: list[Tag]: List of `tiktok_crawler.entities.Tag` \"\"\" _tags = [] for tag in video_description.find_elements(By.XPATH, foryoupage.Caption.TAGS): link = tag.get_attribute(\"href\") text = tag.find_element(By.XPATH, foryoupage.Tag.TEXT).text _tags.append( Tag( link=link, text=text, element=tag ) ) return _tags","title":"CrawlerForYouPage"},{"location":"crawler/#tiktok_crawler.crawler.foryoupage.CrawlerForYouPage.get_tiktok_videos","text":"Downloads videos and metadata from the for you page of Tiktok. Returns: Type Description list [ Tiktok ] list[Tiktok]: list of tiktok_crawler.entities.Tiktok Source code in tiktok_crawler\\crawler\\foryoupage.py def get_tiktok_videos(self) -> list[Tiktok]: \"\"\"Downloads videos and metadata from the **for you** page of Tiktok. Returns: list[Tiktok]: list of `tiktok_crawler.entities.Tiktok` \"\"\" self._load_tiktok_videos() tiktoks = [] for element in self.root.find_elements(By.XPATH, foryoupage.ContainerItem.CONTAINERS)[:self.limit]: logging.info(\"Scrolling to Element...\") self.driver.execute_script(\"arguments[0].scrollIntoView()\", element) time.sleep(Config.CRAWL_SCROLL_PAUSE_TIME) tiktok = self._get_tiktok(element) tiktoks.append(tiktok) return tiktoks","title":"get_tiktok_videos()"},{"location":"entities/","text":"Entities Model class representation of all the parts of a Tiktok video. Parts such as: the user who posted the video, captions, media, metrics, music. Author dataclass Bases: TiktokEntity Model class representation of the user who posted the Tiktok video aka author. Parameters: Name Type Description Default uniqueid str Username of the author. required avatar str Link to the avatar image of the author. required link str Link to the profile of the author. required nickname str Nickname of the author. required element WebElement The Selenium web element which contains the details of the author. required Source code in tiktok_crawler\\entities.py @dataclass class Author(TiktokEntity): \"\"\"Model class representation of the user who posted the Tiktok video aka author. Args: uniqueid (str): Username of the author. avatar (str): Link to the avatar image of the author. link (str): Link to the profile of the author. nickname (str): Nickname of the author. element (WebElement): The Selenium web element which contains the details of the author. \"\"\" uniqueid: str avatar: str link: str nickname: str element: WebElement def __post_init__(self): self.uniqueid = self.uniqueid.strip() self.avatar = self.avatar.strip() self.link = self.link.strip() self.nickname = self.nickname.strip() def __eq__(self, obj) -> bool: return (self.uniqueid == obj.uniqueid) \\ and (self.link == obj.link) def __repr__(self): return f\"Author(uniqueid={self.uniqueid}, nickname={self.nickname})\" def to_dict(self): return dict( uniqueid=self.uniqueid, nickname=self.nickname, link=self.link, avatar=self.avatar, ) Caption dataclass Bases: TiktokEntity Model class representation of the caption in a Tiktok video. Parameters: Name Type Description Default text str The caption in text format. required tags list [ Tag ] List of tags inside the caption. required element WebElement The Selenium web element which contains the details of the caption. required Source code in tiktok_crawler\\entities.py @dataclass class Caption(TiktokEntity): \"\"\"Model class representation of the caption in a Tiktok video. Args: text (str): The caption in text format. tags (list[Tag]): List of tags inside the caption. element (WebElement): The Selenium web element which contains the details of the caption. \"\"\" text: str tags: list[Tag] element: WebElement def __post_init__(self): self.text = self.text.strip() def __repr__(self): return f\"Caption(text={self.text}, tags={self.tags})\" def to_dict(self): return dict( tags=[tag.to_dict() for tag in self.tags], text=self.text, ) Media dataclass Bases: TiktokEntity Model class representation of the Tiktok video. Parameters: Name Type Description Default link str The link of the video. required element WebElement The Selenium web element which contains the details of the video. required Source code in tiktok_crawler\\entities.py @dataclass class Media(TiktokEntity): \"\"\"Model class representation of the Tiktok video. Args: link (str): The link of the video. element (WebElement): The Selenium web element which contains the details of the video. \"\"\" link: str element: WebElement def __post_init__(self): self.link = self.link.strip() def __repr__(self): return f\"Media(link={self.link})\" def to_dict(self): return dict( link=self.link, ) Metrics dataclass Bases: TiktokEntity Model class representation of the metrics generated by the Tiktok video at a specific point of time. Parameters: Name Type Description Default likes str The raw number of likes extracted. required comments str The raw number of comments extracted. required shares str The raw number of shares extracted. required element WebElement The Selenium web element which contains the metrics. required as_of str The date time when the metrics are extracted in iso 8601 format. Defaults to the current date time. datetime.datetime.now().isoformat() Source code in tiktok_crawler\\entities.py @dataclass class Metrics(TiktokEntity): \"\"\"Model class representation of the metrics generated by the Tiktok video at a specific point of time. Args: likes (str): The raw number of likes extracted. comments (str): The raw number of comments extracted. shares (str): The raw number of shares extracted. element (WebElement): The Selenium web element which contains the metrics. as_of (str): The date time when the metrics are extracted in iso 8601 format. Defaults to the current date time. \"\"\" likes: str comments: str shares: str element: WebElement as_of: str = datetime.datetime.now().isoformat() def __post_init__(self): self.likes = self.likes.strip() self.comments = self.comments.strip() self.shares = self.shares.strip() def __repr__(self): return f\"Metrics(likes={self.likes}, comments={self.comments},shares={self.shares}, as_of={self.as_of} )\" def to_dict(self): return dict( likes=self.likes, comments=self.comments, shares=self.shares, as_of=self.as_of, ) Music dataclass Bases: TiktokEntity Model class representation of the music used in a Tiktok video. Parameters: Name Type Description Default title str The title of the music. required link str The link of the music . required element WebElement The Selenium web element which contains the details of the music. required Source code in tiktok_crawler\\entities.py @dataclass class Music(TiktokEntity): \"\"\"Model class representation of the music used in a Tiktok video. Args: title (str): The title of the music. link (str): The link of the music . element (WebElement): The Selenium web element which contains the details of the music. \"\"\" title: str link: str element: WebElement def __post_init__(self): self.title = self.title.strip() self.link = self.link.strip() def __eq__(self, obj) -> bool: return (self.title == obj.title) \\ and (self.link == obj.link) def __repr__(self): return f\"Music(title={self.title}, link={self.link})\" def to_dict(self): return dict( title=self.title, link=self.link, ) Tag dataclass Bases: TiktokEntity Model class representation of a tag in Tiktok. A tag or hashtag is a text preceded by a hash sign (#) which is used to categorize posts. Parameters: Name Type Description Default link str The link of the tag. required text str The text of the tag. required element WebElement The Selenium web element which contains the details of the tag. required Source code in tiktok_crawler\\entities.py @dataclass class Tag(TiktokEntity): \"\"\"Model class representation of a tag in Tiktok. A tag or hashtag is a text preceded by a hash sign (#) which is used to categorize posts. Args: link (str): The link of the tag. text (str): The text of the tag. element (WebElement): The Selenium web element which contains the details of the tag. \"\"\" link: str text: str element: WebElement def __post_init__(self): self.link = self.link.strip() self.text = self.text.strip() def __eq__(self, obj) -> bool: return (self.text == obj.text) \\ and (self.link == obj.link) def __repr__(self): return f\"Tag(link={self.link}, text={self.text})\" def to_dict(self): return dict( link=self.link, text=self.text ) Tiktok dataclass Model class representation of the Tiktok video to be extracted. This class utilizes all the other entities dataclasses. Parameters: Name Type Description Default id str Unique internal id of the Tiktok video. required author Author entities.Author instance of the Tiktok video. required caption Caption entities.Caption instance of the Tiktok video. required music Music entities.Music instance of the Tiktok video. required media Media entities.Media instance of the Tiktok video. required metrics Metrics entities.Metrics instance of the Tiktok video. required element WebElement The Selenium web element which contains the Tiktok video. required status str A tag to signify if the scrape was sucessful. None Source code in tiktok_crawler\\entities.py @dataclass class Tiktok: \"\"\"Model class representation of the Tiktok video to be extracted. This class utilizes all the other `entities` dataclasses. Args: id (str): Unique internal id of the Tiktok video. author (Author): `entities.Author` instance of the Tiktok video. caption (Caption): `entities.Caption` instance of the Tiktok video. music (Music): `entities.Music` instance of the Tiktok video. media (Media): `entities.Media` instance of the Tiktok video. metrics (Metrics): `entities.Metrics` instance of the Tiktok video. element (WebElement): The Selenium web element which contains the Tiktok video. status (str): A tag to signify if the scrape was sucessful. \"\"\" id: str author: Author caption: Caption music: Music media: Media metrics: Metrics element: WebElement status: str = None def save(self, path:str = \"./\"): def _save_metadata(path): file_path = os.path.join(path, f\"{self.id}.json\") with open(file_path, 'w+') as file: json.dump(self.to_dict(), file) def _save_video(path): file_path = os.path.join(path, f\"{self.id}.mp4\") response = requests.get(self.media.link) with open(file_path, \"wb\") as file: file.write(response.content) if self.media.link: logging.info(\"Saving Tiktok...\") _save_metadata(path) _save_video(path) else: logging.error(\"Media is NULL\") def to_dict(self): return dict( id=self.id, Author=self.author.to_dict(), Caption=self.caption.to_dict(), Music=self.music.to_dict(), Media=self.media.to_dict(), Metrics=self.metrics.to_dict(), Status=self.status ) def __eq__(self, obj) -> bool: return self.id == obj.id def __repr__(self) -> str: return f\"Tiktok(id={self.id}, {self.status}, {self.author}, {self.caption}, {self.music}, {self.media}, {self.metrics})\"","title":"Entities"},{"location":"entities/#entities","text":"Model class representation of all the parts of a Tiktok video. Parts such as: the user who posted the video, captions, media, metrics, music.","title":"Entities"},{"location":"entities/#tiktok_crawler.entities.Author","text":"Bases: TiktokEntity Model class representation of the user who posted the Tiktok video aka author. Parameters: Name Type Description Default uniqueid str Username of the author. required avatar str Link to the avatar image of the author. required link str Link to the profile of the author. required nickname str Nickname of the author. required element WebElement The Selenium web element which contains the details of the author. required Source code in tiktok_crawler\\entities.py @dataclass class Author(TiktokEntity): \"\"\"Model class representation of the user who posted the Tiktok video aka author. Args: uniqueid (str): Username of the author. avatar (str): Link to the avatar image of the author. link (str): Link to the profile of the author. nickname (str): Nickname of the author. element (WebElement): The Selenium web element which contains the details of the author. \"\"\" uniqueid: str avatar: str link: str nickname: str element: WebElement def __post_init__(self): self.uniqueid = self.uniqueid.strip() self.avatar = self.avatar.strip() self.link = self.link.strip() self.nickname = self.nickname.strip() def __eq__(self, obj) -> bool: return (self.uniqueid == obj.uniqueid) \\ and (self.link == obj.link) def __repr__(self): return f\"Author(uniqueid={self.uniqueid}, nickname={self.nickname})\" def to_dict(self): return dict( uniqueid=self.uniqueid, nickname=self.nickname, link=self.link, avatar=self.avatar, )","title":"Author"},{"location":"entities/#tiktok_crawler.entities.Caption","text":"Bases: TiktokEntity Model class representation of the caption in a Tiktok video. Parameters: Name Type Description Default text str The caption in text format. required tags list [ Tag ] List of tags inside the caption. required element WebElement The Selenium web element which contains the details of the caption. required Source code in tiktok_crawler\\entities.py @dataclass class Caption(TiktokEntity): \"\"\"Model class representation of the caption in a Tiktok video. Args: text (str): The caption in text format. tags (list[Tag]): List of tags inside the caption. element (WebElement): The Selenium web element which contains the details of the caption. \"\"\" text: str tags: list[Tag] element: WebElement def __post_init__(self): self.text = self.text.strip() def __repr__(self): return f\"Caption(text={self.text}, tags={self.tags})\" def to_dict(self): return dict( tags=[tag.to_dict() for tag in self.tags], text=self.text, )","title":"Caption"},{"location":"entities/#tiktok_crawler.entities.Media","text":"Bases: TiktokEntity Model class representation of the Tiktok video. Parameters: Name Type Description Default link str The link of the video. required element WebElement The Selenium web element which contains the details of the video. required Source code in tiktok_crawler\\entities.py @dataclass class Media(TiktokEntity): \"\"\"Model class representation of the Tiktok video. Args: link (str): The link of the video. element (WebElement): The Selenium web element which contains the details of the video. \"\"\" link: str element: WebElement def __post_init__(self): self.link = self.link.strip() def __repr__(self): return f\"Media(link={self.link})\" def to_dict(self): return dict( link=self.link, )","title":"Media"},{"location":"entities/#tiktok_crawler.entities.Metrics","text":"Bases: TiktokEntity Model class representation of the metrics generated by the Tiktok video at a specific point of time. Parameters: Name Type Description Default likes str The raw number of likes extracted. required comments str The raw number of comments extracted. required shares str The raw number of shares extracted. required element WebElement The Selenium web element which contains the metrics. required as_of str The date time when the metrics are extracted in iso 8601 format. Defaults to the current date time. datetime.datetime.now().isoformat() Source code in tiktok_crawler\\entities.py @dataclass class Metrics(TiktokEntity): \"\"\"Model class representation of the metrics generated by the Tiktok video at a specific point of time. Args: likes (str): The raw number of likes extracted. comments (str): The raw number of comments extracted. shares (str): The raw number of shares extracted. element (WebElement): The Selenium web element which contains the metrics. as_of (str): The date time when the metrics are extracted in iso 8601 format. Defaults to the current date time. \"\"\" likes: str comments: str shares: str element: WebElement as_of: str = datetime.datetime.now().isoformat() def __post_init__(self): self.likes = self.likes.strip() self.comments = self.comments.strip() self.shares = self.shares.strip() def __repr__(self): return f\"Metrics(likes={self.likes}, comments={self.comments},shares={self.shares}, as_of={self.as_of} )\" def to_dict(self): return dict( likes=self.likes, comments=self.comments, shares=self.shares, as_of=self.as_of, )","title":"Metrics"},{"location":"entities/#tiktok_crawler.entities.Music","text":"Bases: TiktokEntity Model class representation of the music used in a Tiktok video. Parameters: Name Type Description Default title str The title of the music. required link str The link of the music . required element WebElement The Selenium web element which contains the details of the music. required Source code in tiktok_crawler\\entities.py @dataclass class Music(TiktokEntity): \"\"\"Model class representation of the music used in a Tiktok video. Args: title (str): The title of the music. link (str): The link of the music . element (WebElement): The Selenium web element which contains the details of the music. \"\"\" title: str link: str element: WebElement def __post_init__(self): self.title = self.title.strip() self.link = self.link.strip() def __eq__(self, obj) -> bool: return (self.title == obj.title) \\ and (self.link == obj.link) def __repr__(self): return f\"Music(title={self.title}, link={self.link})\" def to_dict(self): return dict( title=self.title, link=self.link, )","title":"Music"},{"location":"entities/#tiktok_crawler.entities.Tag","text":"Bases: TiktokEntity Model class representation of a tag in Tiktok. A tag or hashtag is a text preceded by a hash sign (#) which is used to categorize posts. Parameters: Name Type Description Default link str The link of the tag. required text str The text of the tag. required element WebElement The Selenium web element which contains the details of the tag. required Source code in tiktok_crawler\\entities.py @dataclass class Tag(TiktokEntity): \"\"\"Model class representation of a tag in Tiktok. A tag or hashtag is a text preceded by a hash sign (#) which is used to categorize posts. Args: link (str): The link of the tag. text (str): The text of the tag. element (WebElement): The Selenium web element which contains the details of the tag. \"\"\" link: str text: str element: WebElement def __post_init__(self): self.link = self.link.strip() self.text = self.text.strip() def __eq__(self, obj) -> bool: return (self.text == obj.text) \\ and (self.link == obj.link) def __repr__(self): return f\"Tag(link={self.link}, text={self.text})\" def to_dict(self): return dict( link=self.link, text=self.text )","title":"Tag"},{"location":"entities/#tiktok_crawler.entities.Tiktok","text":"Model class representation of the Tiktok video to be extracted. This class utilizes all the other entities dataclasses. Parameters: Name Type Description Default id str Unique internal id of the Tiktok video. required author Author entities.Author instance of the Tiktok video. required caption Caption entities.Caption instance of the Tiktok video. required music Music entities.Music instance of the Tiktok video. required media Media entities.Media instance of the Tiktok video. required metrics Metrics entities.Metrics instance of the Tiktok video. required element WebElement The Selenium web element which contains the Tiktok video. required status str A tag to signify if the scrape was sucessful. None Source code in tiktok_crawler\\entities.py @dataclass class Tiktok: \"\"\"Model class representation of the Tiktok video to be extracted. This class utilizes all the other `entities` dataclasses. Args: id (str): Unique internal id of the Tiktok video. author (Author): `entities.Author` instance of the Tiktok video. caption (Caption): `entities.Caption` instance of the Tiktok video. music (Music): `entities.Music` instance of the Tiktok video. media (Media): `entities.Media` instance of the Tiktok video. metrics (Metrics): `entities.Metrics` instance of the Tiktok video. element (WebElement): The Selenium web element which contains the Tiktok video. status (str): A tag to signify if the scrape was sucessful. \"\"\" id: str author: Author caption: Caption music: Music media: Media metrics: Metrics element: WebElement status: str = None def save(self, path:str = \"./\"): def _save_metadata(path): file_path = os.path.join(path, f\"{self.id}.json\") with open(file_path, 'w+') as file: json.dump(self.to_dict(), file) def _save_video(path): file_path = os.path.join(path, f\"{self.id}.mp4\") response = requests.get(self.media.link) with open(file_path, \"wb\") as file: file.write(response.content) if self.media.link: logging.info(\"Saving Tiktok...\") _save_metadata(path) _save_video(path) else: logging.error(\"Media is NULL\") def to_dict(self): return dict( id=self.id, Author=self.author.to_dict(), Caption=self.caption.to_dict(), Music=self.music.to_dict(), Media=self.media.to_dict(), Metrics=self.metrics.to_dict(), Status=self.status ) def __eq__(self, obj) -> bool: return self.id == obj.id def __repr__(self) -> str: return f\"Tiktok(id={self.id}, {self.status}, {self.author}, {self.caption}, {self.music}, {self.media}, {self.metrics})\"","title":"Tiktok"}]}